// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v4.23.2
// source: api/compute/v1/vm.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationVmCreateVm = "/api.compute.v1.Vm/CreateVm"
const OperationVmDeleteVm = "/api.compute.v1.Vm/DeleteVm"
const OperationVmGetVm = "/api.compute.v1.Vm/GetVm"
const OperationVmListVm = "/api.compute.v1.Vm/ListVm"
const OperationVmStartVm = "/api.compute.v1.Vm/StartVm"
const OperationVmStopVm = "/api.compute.v1.Vm/StopVm"

type VmHTTPServer interface {
	CreateVm(context.Context, *CreateVmRequest) (*GetVmReply, error)
	DeleteVm(context.Context, *DeleteVmRequest) (*DeleteVmReply, error)
	GetVm(context.Context, *GetVmRequest) (*GetVmReply, error)
	ListVm(context.Context, *ListVmRequest) (*ListVmReply, error)
	StartVm(context.Context, *GetVmRequest) (*GetVmReply, error)
	StopVm(context.Context, *GetVmRequest) (*GetVmReply, error)
}

func RegisterVmHTTPServer(s *http.Server, srv VmHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/vm", _Vm_CreateVm0_HTTP_Handler(srv))
	r.DELETE("/v1/vm/{id}", _Vm_DeleteVm0_HTTP_Handler(srv))
	r.GET("/v1/vm/{id}", _Vm_GetVm0_HTTP_Handler(srv))
	r.GET("/v1/vm", _Vm_ListVm0_HTTP_Handler(srv))
	r.PUT("/v1/vm/{id}/start", _Vm_StartVm0_HTTP_Handler(srv))
	r.PUT("/v1/vm/{id}/stop", _Vm_StopVm0_HTTP_Handler(srv))
}

func _Vm_CreateVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateVmRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmCreateVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateVm(ctx, req.(*CreateVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVmReply)
		return ctx.Result(200, reply)
	}
}

func _Vm_DeleteVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteVmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmDeleteVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteVm(ctx, req.(*DeleteVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteVmReply)
		return ctx.Result(200, reply)
	}
}

func _Vm_GetVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetVmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmGetVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetVm(ctx, req.(*GetVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVmReply)
		return ctx.Result(200, reply)
	}
}

func _Vm_ListVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListVmRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmListVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListVm(ctx, req.(*ListVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListVmReply)
		return ctx.Result(200, reply)
	}
}

func _Vm_StartVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetVmRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmStartVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StartVm(ctx, req.(*GetVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVmReply)
		return ctx.Result(200, reply)
	}
}

func _Vm_StopVm0_HTTP_Handler(srv VmHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetVmRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationVmStopVm)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.StopVm(ctx, req.(*GetVmRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetVmReply)
		return ctx.Result(200, reply)
	}
}

type VmHTTPClient interface {
	CreateVm(ctx context.Context, req *CreateVmRequest, opts ...http.CallOption) (rsp *GetVmReply, err error)
	DeleteVm(ctx context.Context, req *DeleteVmRequest, opts ...http.CallOption) (rsp *DeleteVmReply, err error)
	GetVm(ctx context.Context, req *GetVmRequest, opts ...http.CallOption) (rsp *GetVmReply, err error)
	ListVm(ctx context.Context, req *ListVmRequest, opts ...http.CallOption) (rsp *ListVmReply, err error)
	StartVm(ctx context.Context, req *GetVmRequest, opts ...http.CallOption) (rsp *GetVmReply, err error)
	StopVm(ctx context.Context, req *GetVmRequest, opts ...http.CallOption) (rsp *GetVmReply, err error)
}

type VmHTTPClientImpl struct {
	cc *http.Client
}

func NewVmHTTPClient(client *http.Client) VmHTTPClient {
	return &VmHTTPClientImpl{client}
}

func (c *VmHTTPClientImpl) CreateVm(ctx context.Context, in *CreateVmRequest, opts ...http.CallOption) (*GetVmReply, error) {
	var out GetVmReply
	pattern := "/v1/vm"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVmCreateVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VmHTTPClientImpl) DeleteVm(ctx context.Context, in *DeleteVmRequest, opts ...http.CallOption) (*DeleteVmReply, error) {
	var out DeleteVmReply
	pattern := "/v1/vm/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVmDeleteVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VmHTTPClientImpl) GetVm(ctx context.Context, in *GetVmRequest, opts ...http.CallOption) (*GetVmReply, error) {
	var out GetVmReply
	pattern := "/v1/vm/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVmGetVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VmHTTPClientImpl) ListVm(ctx context.Context, in *ListVmRequest, opts ...http.CallOption) (*ListVmReply, error) {
	var out ListVmReply
	pattern := "/v1/vm"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationVmListVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VmHTTPClientImpl) StartVm(ctx context.Context, in *GetVmRequest, opts ...http.CallOption) (*GetVmReply, error) {
	var out GetVmReply
	pattern := "/v1/vm/{id}/start"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVmStartVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *VmHTTPClientImpl) StopVm(ctx context.Context, in *GetVmRequest, opts ...http.CallOption) (*GetVmReply, error) {
	var out GetVmReply
	pattern := "/v1/vm/{id}/stop"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationVmStopVm))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
